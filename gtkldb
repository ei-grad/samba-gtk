#!/usr/bin/python
# coding: utf-8
#
# Unix SMB/CIFS implementation.
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2007
# Copyright (C) Andrew Grigorev <andrew@ei-grad.ru> 2009
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

"""Simple GTK+ frontend for LDB."""

import os
import sys

import gtk
import gobject

import ldb

DEBUG = False

class LdbURLDialog(gtk.Dialog):
    """Dialog that prompts for a LDB URL.
    
    Ideally this should remember LDB urls and list them in a combo box.
    """
    
    def __init__(self, parent=None):
        """Create a new LdbURLDialog.
        
        parent -- Parent window.
        """
        super(LdbURLDialog, self).__init__(parent=parent,
                buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                         gtk.STOCK_OPEN, gtk.RESPONSE_OK))
        hbox = gtk.HBox()
        hbox.set_border_width(5)
        hbox.set_spacing(5)
        hbox.pack_start(gtk.Label("Enter URL:"), expand=False)
        self.url = gtk.Entry()
        hbox.pack_end(self.url)
        self.vbox.add(hbox)
        self.show_all()
        
    def get_url(self):
        """Return url."""
        return self.url.get_text()


class AddObjectDialog(gtk.Dialog):
    """Dialog that prompts for an object name, classes and properties."""
    
    def __init__(self, parent=None):
        """Create a new AddObjectDialog.
        
        parent -- Parent window.
        """
        super(AddObjectDialog, self).__init__(parent=parent,
            buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                     gtk.STOCK_ADD, gtk.RESPONSE_OK),
            title="Add an object")
        
        hbox = gtk.HBox()
        hbox.set_border_width(5)
        hbox.set_spacing(5)
        hbox.pack_start(gtk.Label("Enter DN:"), expand=False)
        self.dn_entry = gtk.Entry()
        hbox.pack_end(self.dn_entry)
        self.vbox.add(hbox)
        self.show_all()
        
    def get_dn(self):
        """Return a DN string"""
        return self.dn_entry.get_text()


def get_ldb(url):
    """Create a new LDB object.
    
    url -- LDB URL to connect to.
    """
    ret = ldb.Ldb()
    path = os.getenv("LDB_MODULES_PATH")
    if path is not None:
        ret.set_modules_dir(path)
    ret.connect(url)
    return ret

def get_rdn(dn):
    """Get relative distinguished name.
    
    dn --- distinguished name
    """
    _len = dn.find(",")
    if _len == -1:
        return dn
    else:
        return dn[:_len]


class DnTree:
    """Represents set of dn as a tree."""
    
    def __init__(self, all_dn=set()):
        """Initialize tree.
        
        all_dn --- set of dn to add in tree
        """
        self.childs = {}
        self.parent = {}
        self.fake_parent = {}
        
        self.dn_set = set()
        
        self.parent[""] = ""
        self.childs[""] = [] # used by get_roots()
        
        for dn in all_dn:
            self.add(dn)
            
    def __str__(self):
        
        def print_dn(dn, offset=0):
            if self.parent[dn] == "":
                ret1 = "%s%s\n" % ( " " * offset, dn)
            else:
                ret1 = "%s%s\n" % ( " " * offset, get_rdn(dn))
            try:
                for i in self.childs[dn]:
                    ret1 += print_dn(i, offset+4)
            except KeyError:
                pass
            finally:
                return ret1
            
        ret = ""
        for i in self.get_roots():
            ret += print_dn(i)
        return ret
    
    def get_roots(self):
        """Get list of root nodes of tree."""
        try:
            return self.childs[""]
        except KeyError:
            return []
            
    def get_parent_dn(self, dn):
        """Get distinguished name of parent node is this tree.
        
        dn --- distinguished name of node, which parent to return
        """
        _len = dn.find(",")
        if _len == -1:
            return ""
        else:
            if dn[_len+1:] in self.dn_set:
                return dn[_len+1:]
            else:
                return ""
            
    def get_fake_parent_dn(self, dn):
        """Get distinguished name of node that should be a parent node of node dn.
        
        dn --- distinguished name of node, which parent to return
        """
        _len = dn.find(",")
        if _len == -1:
            return ""
        else:
            return dn[_len+1:]
    
    def add(self, dn):
        """Add node to tree.
        
        dn --- distinguished name of node.
        """
        
        if DEBUG:
            print 'tree add %s' % dn
            
        if dn in self.dn_set:
            raise ValueError('A record with dn=%s already exists!' % dn)
        self.dn_set.add(dn)
        
        parent_dn = self.get_parent_dn(dn)
        fake_parent = self.get_fake_parent_dn(dn)
        
        if parent_dn != fake_parent:
            try:
                self.fake_parent[fake_parent].append(dn)
            except KeyError:
                self.fake_parent[fake_parent] = [dn]
                    
        self.parent[dn] = parent_dn
        try:
            self.childs[parent_dn].append(dn)
        except KeyError:
            self.childs[parent_dn] = [dn]
            
        try:
            for i in self.fake_parent.pop(dn):
                self.childs[""].remove(i)
                self.parent[i] = dn
                try:
                    self.childs[dn].append(i)
                except KeyError:
                    self.childs[dn] = [i]
        except KeyError:
            pass
            
    def rename(self, old_dn, new_dn):
        """Rename node.
        
        old_dn --- old distinguished name of node.
        new_dn --- new distinguished name of node.
        """
        if old_dn not in self.dn_set:
            raise ValueError('A record with dn=%s doesn\'t exists!' % new_dn)
        if new_dn in self.dn_set:
            raise ValueError('A record with dn=%s already exists!' % new_dn)
        self.remove(old_dn)
        self.add(new_dn)
        
    def remove(self, dn):
        """Remove node from tree.
        
        dn --- distinguished name of node.
        """
        
        if dn not in self.dn_set:
            raise ValueError('A record with dn=%s doesn\'t exists!' % dn)
        
        parent = self.get_parent_dn(dn)
        
        self.childs[parent].remove(dn)
        
        if dn in self.childs.keys():
            childs = tuple(self.childs[dn])
            for i in childs:
                self.remove(i)
            if DEBUG:
                if len(self.childs[dn]) > 0:
                    print 'error!'
            self.childs.pop(dn)
                
        self.parent.pop(dn)
        
        if DEBUG:
            if dn in self.fake_parent.keys():
                print 'Strange, %s in fake_parent.' % dn
        
        self.dn_set.remove(dn)


def print_ldb_tree(url):
    """Prints ldb tree.
    
    url --- Ldb url to connect.
    """
    
    print(DnTree(set(map(lambda x: str(x.dn),
                     filter(lambda x: not x.dn.is_special(),
                            get_ldb(url).search(attrs=['dn']))))))


class LdbBrowser(gtk.Window):
    """GTK+ based LDB browser."""
    
    def set_ldb(self, ldb):
        """Change the LDB object displayed.
        
        Will refresh the window.
        ldb -- New LDB object to use.
        """
        self.ldb = ldb
        self.menu_disconnect.set_sensitive(True)
        self.rebuild_tree()
        
    def _cb_connect(self, button):
        dialog = LdbURLDialog()
        if dialog.run() == gtk.RESPONSE_OK:
            try:
                self.set_ldb(get_ldb(dialog.get_url()))
            except ldb.LdbError, err:
                dialog2 = gtk.MessageDialog(self,
                    gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR,
                    gtk.BUTTONS_CLOSE, str(err))
                # Close dialog on user response
                dialog2.connect ("response", lambda d, r: d.destroy())
                dialog2.show()
        dialog.destroy()
        
    def _cb_open(self, button):
        dialog = gtk.FileChooserDialog(title="Please choose a file",
            parent=self,
            buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                gtk.STOCK_OPEN, gtk.RESPONSE_OK))
        if dialog.run() == gtk.RESPONSE_OK:
            self.set_ldb(get_ldb(dialog.get_filename()))
            
        dialog.destroy()
        
    def _cb_disconnect(self, button):
        self.treemodel.clear()
        self.attributemodel.clear()
        self.menu_disconnect.set_sensitive(False)
        self.ldb = None
        
    def add_node(self, dn, parent_dn=None, parent_node=None, text=None):
        """Add node to treemodel.
        
        dn          --- distinguished name of node (str)
        parent_dn   --- distinguished name of parent node (str)
        parent_node --- parent node (gtk.TreeIter)
        text        --- caption of node (str)
        """
        if parent_dn == None: parent_dn = self.tree.get_parent_dn(dn)
        if parent_node == None: parent_node = self.treenodes[parent_dn]
        if text == None:
            if parent_dn == "":
                text = dn
            else:
                text = get_rdn(dn)
        
        if DEBUG:
            print "add_node: adding node", dn
            print "add_node: parent:", parent_dn
            print "add_node: parent iter:", parent_node
            print "add_node: text:", text
        
        if dn in self.treenodes.keys():
            if DEBUG:
                print "add_node: old entry found"
            self.remove_node(dn)
            if DEBUG:
                print "add_node: old entry removed."
        
        cur_node = self.treemodel.append(parent_node, [text, dn, True])
        self.treenodes[dn] = cur_node
        
        if DEBUG:
            print "add_node: new iter:", cur_node
            print
        
        if dn in self.tree.childs.keys():
            for child in self.tree.childs[dn]:
                self.add_node(child, dn, cur_node)
                
    def remove_node(self, dn):
        """Remove node from treemodel.
        
        dn --- distinguished name of node to remove (str)
        """
        
        if dn in self.tree.childs.keys():
            childs = tuple(self.tree.childs[dn])
            for i in childs:
                self.remove_node(i)
                
        if DEBUG:
            print 'remove_node %s' % dn
            try:
                print 'childs:\n    %s' % "\n    ".join(childs)
            except NameError:
                pass
            
        self.treemodel.remove(self.treenodes[dn])
        self.treenodes.pop(dn)
        
    def get_all_dn_set(self):
        """Return set of dn strings of elements in database."""
        if self.hide_special:
            return set(map(lambda x: str(x.dn),
                                  filter(lambda x: not x.dn.is_special(),
                                        self.ldb.search(attrs=['dn']))))
        else:
            return set(map(lambda x: str(x.dn),
                                        self.ldb.search(attrs=['dn'])))
        
    def rebuild_tree(self):
        """Rebuild LDB tree and display it in treeview."""
        
        self.tree = DnTree(self.get_all_dn_set())
        
        if DEBUG:
            print self.tree
        
        self.treemodel.clear()
        self.treenodes = {}
        self.treenodes[""] = None
        
        root_dn = self.tree.get_roots()
        root_dn.sort()
        for dn in root_dn:
            self.add_node(dn, "", text=dn)
        
    def sync_tree(self):
        """Syncronize tree and treeview with database after minor change."""
       
        if DEBUG: print 'sync_tree: begin'
        
        new_dn_set = self.get_all_dn_set()
        
        dn_to_remove = self.tree.dn_set.difference(new_dn_set)
        
        if DEBUG:
            print 'sync_tree: dn_to_remove\n%s\n' % DnTree(dn_to_remove)
        
        for dn in DnTree(dn_to_remove).get_roots():
            if DEBUG: print 'sync_tree: removing %s' % dn
            self.remove_node(dn)
            self.tree.remove(dn)
        
        dn_to_add = new_dn_set.difference(self.tree.dn_set)
        
        if DEBUG:
            print 'sync_tree: dn_to_add\n%s\n' % DnTree(dn_to_add)
        
        for dn in dn_to_add:
            if DEBUG: print 'sync_tree: adding %s to tree' % dn
            self.tree.add(dn)
            
        for dn in DnTree(dn_to_add).get_roots():
            if DEBUG: print 'sync_tree: adding to treemodel %s' % dn
            self.add_node(dn)

        if DEBUG: print 'sync_tree: end'
        
    def _toggle_special_entries(self, item):
        self.hide_special = not self.hide_special
        if self.ldb != None:
            self.sync_tree()
            
    def _treeview_cursor_cb(self, item):
        (model, iter) = item.get_selection().get_selected()
        dn = model.get_value(iter, 1)
        self.attributemodel.clear()
        msg = self.ldb.search(dn, ldb.SCOPE_BASE)
        if len(msg) > 0:
            for name, el in msg[0].items():
                if name == "dn":
                    continue
                for val in set(el):
                    self.attributemodel.append([name, val, el])
                    
    def _add_object(self, action):
        """Add object to ldb and treeview."""
        if self.ldb == None:
            dialog = gtk.MessageDialog(self,
                gtk.DIALOG_DESTROY_WITH_PARENT | gtk.DIALOG_MODAL,
                gtk.MESSAGE_INFO, gtk.BUTTONS_CLOSE,
                "Connect to LDB database first.")
            # Close dialog on user response
            dialog.connect ("response", lambda d, r: d.destroy())
            dialog.show()
            return
        dialog = AddObjectDialog(parent=self)
        if dialog.run() == gtk.RESPONSE_OK:
            try:
                dn = dialog.get_dn()
                dialog.destroy()
                if DEBUG:
                    print '_add_object: %s' % dn
                msg = ldb.Message(ldb.Dn(self.ldb, dn))
                self.ldb.add(msg)
                self.sync_tree()
            except (ldb.LdbError, ValueError), err:
                dialog2 = gtk.MessageDialog(self,
                    gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR,
                    gtk.BUTTONS_CLOSE, str(err))
                # Close dialog on user response
                dialog2.connect ("response", lambda d, r: d.destroy())
                dialog2.show()
        else:
            dialog.destroy()
            
    def _remove_object(self, action):
        """Show dialog that prompts for DN, and delete if it is selected."""
        if self.ldb == None:
            dialog = gtk.MessageDialog(self,
                gtk.DIALOG_DESTROY_WITH_PARENT | gtk.DIALOG_MODAL,
                gtk.MESSAGE_INFO, gtk.BUTTONS_CLOSE,
                "Connect to LDB database first.")
            # Close dialog on user response
            dialog.connect ("response", lambda d, r: d.destroy())
            dialog.show()
            return
        dialog = gtk.Dialog(parent=self, buttons=(gtk.STOCK_CANCEL,
            gtk.RESPONSE_CANCEL, gtk.STOCK_DELETE, gtk.RESPONSE_OK),
            title="Enter DN:")
        dn_entry = gtk.Entry()
        dialog.vbox.add(dn_entry)
        dialog.show_all()
        if dialog.run() == gtk.RESPONSE_OK:
            try:
                _dn = dn_entry.get_text()
                dialog.destroy()
                if DEBUG:
                    print '_remove_object: %s' % _dn
                self.ldb.delete(ldb.Dn(self.ldb, _dn))
                self.sync_tree()
            except (ldb.LdbError, ValueError), err:
                dialog2 = gtk.MessageDialog(self,
                    gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR,
                    gtk.BUTTONS_CLOSE, str(err))
                # Close dialog on user response
                dialog2.connect ("response", lambda d, r: d.destroy())
                dialog2.show()
        else:
            dialog.destroy()
            
    def _dn_cell_edited(self, cell, path_string, new_rdn):
        """Rename an element."""
        
        # FIXME: don't work with root nodes, that can have rdn consists of
        # several parts, for example DC=part3,DC=part2,DC=part1
        
        # FIXME: don't work with nodes that have childs
        
        iter = self.treemodel.get_iter_from_string(path_string)
        
        old_dn = self.treemodel[iter][1]
        old_rdn = get_rdn(old_dn)
        
        if old_rdn == new_rdn:
            return
        
        parent_dn = self.tree.parent[old_dn]
        
        if parent_dn != "":
            new_dn = new_rdn + "," + parent_dn
        else:
            new_dn = new_rdn
        
        if DEBUG:
            print old_dn, "-->", new_dn
        
        self.ldb.rename(ldb.Dn(self.ldb, old_dn), new_dn)
        
        self.tree.rename(old_dn, new_dn)
        
        self.treemodel.set(iter, 0, new_rdn)
        self.treemodel.set(iter, 1, new_dn)
        
        self.sync_tree()
        
    def about_dialog(self):
        """Show about dialog."""
        dialog = gtk.AboutDialog()
        dialog.set_name(self.get_title())
        dialog.set_website("http://www.samba.org/")
        ## Close dialog on user response
        dialog.connect ("response", lambda d, r: d.destroy())
        dialog.show()
        
    def __init__(self):
        """Create a new LdbBrowser."""
        super(LdbBrowser, self).__init__()
        
        self.ldb = None
        self.hide_special = True
        self.tree = None
        
        vbox = gtk.VBox(spacing=0)
        
        # Menu
        self.menu = gtk.MenuBar()
        
        # menu_db
        menuitem_db = gtk.MenuItem("_Database")
        menu_db = gtk.Menu()
        menuitem_db.set_submenu(menu_db)
        self.menu.add(menuitem_db)
        
        menu_connect = gtk.ImageMenuItem(gtk.STOCK_CONNECT)
        menu_connect.connect('activate', self._cb_connect)
        menu_db.add(menu_connect)
        
        menu_open = gtk.ImageMenuItem(gtk.STOCK_OPEN)
        menu_open.connect('activate', self._cb_open)
        menu_db.add(menu_open)
        
        self.menu_disconnect = gtk.ImageMenuItem(gtk.STOCK_DISCONNECT)
        self.menu_disconnect.connect('activate', self._cb_disconnect)
        self.menu_disconnect.set_sensitive(False)
        menu_db.add(self.menu_disconnect)
        
        menu_db.add(gtk.SeparatorMenuItem())
        
        menu_hide_special = gtk.CheckMenuItem("_Hide special entries")
        menu_hide_special.set_active(self.hide_special)
        menu_hide_special.connect('toggled', self._toggle_special_entries)
        menu_db.add(menu_hide_special)
        
        menu_db.add(gtk.SeparatorMenuItem())
        
        menu_exit = gtk.ImageMenuItem(gtk.STOCK_QUIT)
        menu_exit.connect('activate', lambda x: gtk.main_quit())
        menu_db.add(menu_exit)
        
        # menu_edit
        menuitem_edit = gtk.MenuItem("_Record")
        self.menu_edit = gtk.Menu()
        menuitem_edit.set_submenu(self.menu_edit)
        self.menu.add(menuitem_edit)
        
        menu_add_message = gtk.ImageMenuItem(gtk.STOCK_ADD)
        menu_add_message.connect('activate', self._add_object)
        self.menu_edit.add(menu_add_message)
        
        menu_delete_message = gtk.ImageMenuItem(gtk.STOCK_DELETE)
        menu_delete_message.connect('activate', self._remove_object)
        self.menu_edit.add(menu_delete_message)
        
        # menu_help
        menuitem_help = gtk.MenuItem("_Help")
        self.menu_help = gtk.Menu()
        menuitem_help.set_submenu(self.menu_help)
        self.menu.add(menuitem_help)
        
        menu_about = gtk.ImageMenuItem(gtk.STOCK_ABOUT)
        menu_about.connect('activate', lambda x: self.about_dialog())
        self.menu_help.add(menu_about)
        
        vbox.pack_start(self.menu, expand=False)
        
        # DN's view
        self.treeview = gtk.TreeView()
        self.treemodel = gtk.TreeStore(gobject.TYPE_STRING,
                                       gobject.TYPE_STRING,
                                       gobject.TYPE_BOOLEAN)
        self.treeview.set_model(self.treemodel)
        self.treeview.set_headers_visible(False)
        
        renderer = gtk.CellRendererText()
        renderer.connect("edited", self._dn_cell_edited)
        
        self.treeview.append_column(gtk.TreeViewColumn("_Dn",
                                    renderer, text=0, editable=2))
        self.treeview.connect("cursor-changed", self._treeview_cursor_cb)
        
        # Attributes view
        self.attributeview = gtk.TreeView()
        self.attributemodel = gtk.ListStore(str, str, gobject.TYPE_PYOBJECT)
        self.attributeview.set_model(self.attributemodel)
        self.attributeview.append_column(gtk.TreeViewColumn("_Name",
                                         gtk.CellRendererText(), text=0))
        self.attributeview.append_column(gtk.TreeViewColumn("_Value",
                                         gtk.CellRendererText(), text=1))
        
        # DN's window
        pane = gtk.HPaned()
        pane.set_position(200)
        treeview_window = gtk.ScrolledWindow()
        treeview_window.set_shadow_type(gtk.SHADOW_IN)
        treeview_window.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        treeview_window.add(self.treeview)
        pane.pack1(treeview_window, resize=True, shrink=True)
        
        # Attributes window
        attributeview_window = gtk.ScrolledWindow()
        attributeview_window.set_shadow_type(gtk.SHADOW_IN)
        attributeview_window.set_policy(gtk.POLICY_AUTOMATIC,
            gtk.POLICY_AUTOMATIC)
        attributeview_window.add(self.attributeview)
        pane.pack2(attributeview_window, shrink=True)
        
        vbox.pack_start(pane, fill=True, expand=True)
        
        # Statusbar
        self.statusbar = gtk.Statusbar()
        vbox.pack_end(self.statusbar, expand=False)
        
        self.add(vbox)
        
        self.connect("destroy", gtk.main_quit)
        self.set_default_size(700, 500)
        self.set_title("GTKLDB Editor")
        self.show_all()


def main():
    browser = LdbBrowser()
    if len(sys.argv) > 1:
        browser.set_ldb(get_ldb(sys.argv[1]))
    gtk.main()

if __name__ == "__main__":
    main()
