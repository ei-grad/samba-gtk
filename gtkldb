#!/usr/bin/python
# coding: utf-8
#
# Unix SMB/CIFS implementation.
# Copyright (C) Jelmer Vernooij <jelmer@samba.org> 2007
# Copyright (C) Andrew Grigorev <andrew@ei-grad.ru> 2009
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

"""Simple GTK+ frontend for LDB."""

import os
import sys
import time

import gtk
import gobject

import ldb

__authors__ = ['2007 Jelmer Vernooij <jelmer@samba.org>',
               '2009 Andrew Grigorev <andrew@ei-grad.ru>']
__thanks_to__ = ['Andrew Bartlett <abartlet@samba.org>']
__title__ = "GTKLDB"
DEBUG = False

class LdbURLDialog(gtk.Dialog):
    """Dialog that prompts for a LDB URL.
    
    Ideally this should remember LDB urls and list them in a combo box.
    (create ~/.gtkldb specially for this?)
    """
    
    def __init__(self, parent=None):
        """Create a new LdbURLDialog.
        
        parent -- Parent window.
        """
        super(LdbURLDialog, self).__init__(parent=parent,
                buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                         gtk.STOCK_OPEN, gtk.RESPONSE_OK))
        hbox = gtk.HBox()
        hbox.set_border_width(5)
        hbox.set_spacing(5)
        hbox.pack_start(gtk.Label("Enter URL:"), expand=False)
        self.url = gtk.Entry()
        hbox.pack_end(self.url)
        self.vbox.add(hbox)
        self.show_all()
        
    def get_url(self):
        """Return url."""
        return self.url.get_text()


def get_ldb(url):
    """Create a new LDB object.
    
    url -- LDB URL to connect to.
    """
    ret = ldb.Ldb()
    path = os.getenv("LDB_MODULES_PATH")
    if path is not None:
        ret.set_modules_dir(path)
    ret.connect(url)
    return ret

def get_rdn(dn):
    """Get relative distinguished name.
    
    dn --- distinguished name
    """
    _len = dn.find(",")
    if _len == -1:
        return dn
    else:
        return dn[:_len]


class DnTree:
    """Represents set of dn as a tree."""
    
    def __init__(self, all_dn=set()):
        """Initialize tree.
        
        all_dn --- set of dn to initially add to a tree
        """
        self.childs = {}
        self.parent = {}
        self.fake_parent = {} # distinguished name of a node
                              # that should be a parent
                              # but not exists in a current tree
        
        self.dn_set = set() # all nodes in a tree
        
        self.parent[""] = ""
        self.childs[""] = [] # used by get_roots()
        
        for dn in all_dn:
            self.add(dn)
            
    def __str__(self):
        """Return DnTree as a tree."""
        
        def print_node(dn, offset=0):
            if self.parent[dn] == "":
                ret1 = "%s%s\n" % ( " " * offset, dn)
            else:
                ret1 = "%s%s\n" % ( " " * offset, get_rdn(dn))
            try:
                for i in self.childs[dn]:
                    ret1 += print_node(i, offset+4)
            except KeyError:
                pass
            finally:
                return ret1
            
        ret = ""
        for i in self.get_roots():
            ret += print_node(i)
        return ret
    
    def get_roots(self):
        """Get list of a tree root nodes."""
        try:
            return self.childs[""]
        except KeyError:
            return []
        
    def get_parent_dn(self, dn):
        """Get distinguished name of parent node is this tree.
        
        dn --- distinguished name of node, which parent to return
        """
        _len = dn.find(",")
        if _len == -1:
            return ""
        else:
            if dn[_len+1:] in self.dn_set:
                return dn[_len+1:]
            else:
                return ""
            
    def get_fake_parent_dn(self, dn):
        """Get distinguished name of node that should be a parent node of node
        with distinguished name dn, but not exists in current tree.
        
        dn --- distinguished name of node, which fake parent to return
        """
        _len = dn.find(",")
        if _len == -1:
            return ""
        else:
            return dn[_len+1:]
        
    def add(self, dn):
        """Add node to tree.
        
        dn --- distinguished name of node.
        """
        
        if dn in self.dn_set:
            raise ValueError('A record with dn=%s already exists!' % dn)
            
        
        if DEBUG:
            print 'tree add %s' % dn
        
        parent_dn = self.get_parent_dn(dn)
        fake_parent = self.get_fake_parent_dn(dn)
        
        if parent_dn != fake_parent:
            try:
                self.fake_parent[fake_parent].append(dn)
            except KeyError:
                self.fake_parent[fake_parent] = [dn]
                
        self.parent[dn] = parent_dn
        try:
            self.childs[parent_dn].append(dn)
        except KeyError:
            self.childs[parent_dn] = [dn]
            
        try:
            for i in self.fake_parent.pop(dn):
                if DEBUG:
                    print 'dntree: add: removing %s from childs[""]' % i
                self.childs[""].remove(i)
                self.parent[i] = dn
                try:
                    self.childs[dn].append(i)
                except KeyError:
                    self.childs[dn] = [i]
        except KeyError:
            pass
        
        self.dn_set.add(dn)
        
    def rename(self, old_dn, new_dn):
        """Rename node.
        
        old_dn --- old distinguished name of node.
        new_dn --- new distinguished name of node.
        """
        if old_dn not in self.dn_set:
            raise ValueError('A record with dn=%s doesn\'t exists!' % new_dn)
        if new_dn in self.dn_set:
            raise ValueError('A record with dn=%s already exists!' % new_dn)
        self.remove(old_dn)
        self.add(new_dn)
        
    def remove(self, dn):
        """Remove node from tree.
        
        dn --- distinguished name of node.
        """
        
        if dn not in self.dn_set:
            raise ValueError('A record with dn=%s doesn\'t exists!' % dn)
        
        parent = self.get_parent_dn(dn)
        fake_parent = self.get_fake_parent_dn(dn)
        
        if parent != fake_parent:
            self.fake_parent[fake_parent].remove(dn)
        
        self.childs[parent].remove(dn)
        
        if dn in self.childs.keys():
            childs = tuple(self.childs[dn])
            for i in childs:
                self.remove(i)
            self.childs.pop(dn)
            
        self.parent.pop(dn)
        self.dn_set.remove(dn)


def print_ldb_tree(url):
    """Prints ldb tree.
    
    url --- Ldb url to connect.
    """
    
    print(DnTree(set(map(lambda x: str(x.dn),
                     filter(lambda x: not x.dn.is_special(),
                            get_ldb(url).search(attrs=['dn']))))))

class LdbBrowser(gtk.Window):
    """GTK+ based LDB browser."""
    
    def __init__(self, parent=None):
        """Create a new LdbBrowser."""
        
        super(LdbBrowser, self).__init__()
        try:
            self.set_screen(parent.get_screen())
        except AttributeError:
            self.connect('destroy', lambda *w: gtk.main_quit())
            
        self.set_default_size(700, 500)
        self.set_title(__title__)
        
        self.ldb = None # current ldb connection
        self.hide_special = True # flag to hide special entries
        self.tree = None # DnTree representation of database
        self.cur_selected_dn = None # currently selected item
        self.search_result = None # entries found by search
        
        vbox = gtk.VBox(spacing=0) # base container
        
        def menu():
            """Create a menu."""
            
            def create_action_group():
                # GtkActionEntry
                entries = (
                 ( "DatabaseMenu", None, "_Database" ), # name, stock id, label
                 ( "EditMenu", None, "_Edit" ),         # name, stock id, label
                 ( "HelpMenu", None, "_Help" ),         # name, stock id, label
                 ( "Connect", gtk.STOCK_CONNECT,        # name, stock id
                   None, "<control>N",                  # label, accelerator
                   "Connect to database",               # tooltip
                   self._cb_connect ),
                 ( "Open", gtk.STOCK_OPEN,              # name, stock id
                   None,"<control>O",                   # label, accelerator
                   "Open a file",                       # tooltip
                   self._cb_open ),
                 ( "Disconnect", gtk.STOCK_DISCONNECT,  # name, stock id
                   None,"<control>D",                   # label, accelerator
                   "Close active connection",           # tooltip
                    self._cb_disconnect ),
                 ( "Quit", gtk.STOCK_QUIT,              # name, stock id
                   None, "<control>Q",                  # label, accelerator
                   "Quit",                              # tooltip
                   lambda x: gtk.main_quit() ),
                 ( "Find", gtk.STOCK_FIND,              # name, stock id
                   None, "<control>F",                  # label, accelerator
                   "Find",                              # tooltip
                   self._cb_find ),
                 ( "FindNext", None,                    # name, stock id
                   "Find _next", "F3",                  # label, accelerator
                   "Find next",                         # tooltip
                   lambda x: self.find_next() ),
                 ( "About", gtk.STOCK_ABOUT,            # name, stock id
                   None, None,                          # label, accelerator
                   "About",                             # tooltip
                   self._cb_about ),
                )
                
                # GtkToggleActionEntry
                toggle_entries = (
                 ( "HideSpecial", None,                   # name, stock id
                   "_Hide special entries", "<control>H", # label, accelerator
                   "Bold",                                # tooltip
                   self._toggle_special_entries,
                   True ),                                # is_active
                )
                
                action_group = gtk.ActionGroup("GTKLDBActions")
                action_group.add_actions(entries)
                action_group.add_toggle_actions(toggle_entries)
                
                return action_group
            
            ui_info = \
'''<ui>
  <menubar name='MenuBar'>
    <menu action='DatabaseMenu'>
      <menuitem action='Connect'/>
      <menuitem action='Open'/>
      <menuitem action='Disconnect'/>
      <separator/>
      <menuitem action='Quit'/>
    </menu>
    <menu action='EditMenu'>
      <menuitem action='HideSpecial'/>
      <menuitem action='Find'/>
      <menuitem action='FindNext'/>
    </menu>
    <menu action='HelpMenu'>
      <menuitem action='About'/>
    </menu>
  </menubar>
</ui>'''
            # ui-manager to get easy building menu with accelerators
            merge = gtk.UIManager()
            self.set_data("ui-manager", merge)
            merge.insert_action_group(create_action_group(), 0)
            self.add_accel_group(merge.get_accel_group())
            
            try:
                merge.add_ui_from_string(ui_info)
            except gobject.GError, msg:
                print "building menus failed: %s" % msg
                
            self.menu = merge.get_widget("/MenuBar")
            self.menu.show_all()
            
            self.menu_disconnect = merge.get_widget(
                "/MenuBar/DatabaseMenu/Disconnect")
            
            return self.menu
        
        vbox.pack_start(menu(), expand=False)
        
        # gtk.HPaned
        pane = gtk.HPaned()
        pane.set_position(200)
        
        def treeview():
            """Create widget to display dn tree."""
            
            self.treeview = gtk.TreeView()
            
            self.treeview.connect("button-press-event",
                                    self._dn_button_press)
            
            self.treemodel = gtk.TreeStore(gobject.TYPE_STRING,  # caption
                                           gobject.TYPE_STRING,  # dn
                                           gobject.TYPE_BOOLEAN) # editable
            self.treeview.set_model(self.treemodel)
            self.treeview.set_headers_visible(False)
            
            renderer = gtk.CellRendererText()
            renderer.connect("edited", self._dn_cell_edited)
            
            self.treeview.append_column(gtk.TreeViewColumn("_Dn",
                                        renderer, text=0, editable=2))
            self.treeview.connect("cursor-changed", self._dn_cursor_changed)
            
            window = gtk.ScrolledWindow()
            window.set_shadow_type(gtk.SHADOW_IN)
            window.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
            window.add(self.treeview)
            
            return window
        
        pane.pack1(treeview(), resize=False, shrink=True)
        
        def attributeview():
            """Create widget to display elements of selected node."""
            vbox1 = gtk.VBox()
            self.dn_label = gtk.Label()
            self.dn_label.set_padding(0, 5)
            self.dn_label.set_alignment(gtk.JUSTIFY_LEFT, gtk.JUSTIFY_CENTER)
            self.dn_label.set_selectable(True)
            vbox1.pack_start(self.dn_label, False, False)
            
            self.attributeview = gtk.TreeView()
            
            self.attributeview.connect("button-press-event",
                                        self._msg_button_press)
            
            self.attributemodel = gtk.ListStore(gobject.TYPE_STRING, # name
                                            gobject.TYPE_STRING,     # value
                                            gobject.TYPE_BOOLEAN)    # editable
            self.attributeview.set_model(self.attributemodel)
            
            # name column
            renderer = gtk.CellRendererText()
            renderer.connect("edited", self._msg_cell_edited)
            renderer.set_data("column", 0)
            
            column = gtk.TreeViewColumn("Name", renderer, text=0,
                                        editable=2)
            self.attributeview.append_column(column)
            
            # value column
            renderer = gtk.CellRendererText()
            renderer.connect("edited", self._msg_cell_edited)
            renderer.set_data("column", 1)
            
            column = gtk.TreeViewColumn("Value", renderer, text=1, editable=2)
            self.attributeview.append_column(column)
            
            window = gtk.ScrolledWindow()
            window.set_shadow_type(gtk.SHADOW_IN)
            window.set_policy(gtk.POLICY_AUTOMATIC,
                gtk.POLICY_AUTOMATIC)
            window.add(self.attributeview)
            
            vbox1.add(window)
            
            return vbox1
        
        pane.pack2(attributeview(), shrink=True)
        
        # attach pane to vbox
        vbox.pack_start(pane, fill=True, expand=True)
        
        # attach statusbar to vbox
        self.statusbar = gtk.Statusbar()
        vbox.pack_end(self.statusbar, expand=False)
        
        # attach all to window
        self.add(vbox)
        
        # Show window
        self.show_all()
        
    def ldb_error_exception(self, err):
        """Display MessageDialog with information about an error."""
        
        if DEBUG:
            print "LdbError: %d - %s" % tuple(err)
            
        code, msg = err
        
        if code == 34: # "No messages found" error, it's annoing!
            return
        
        dialog = gtk.MessageDialog(self,
            gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR,
            gtk.BUTTONS_CLOSE, str(msg))
        dialog.set_title("LDB Error %d" % code)
        # Close dialog on user response
        dialog.connect ("response", lambda d, r: d.destroy())
        dialog.show()
        
    def do_search(self):
        """Pass query to ldb and get result."""
        
        def make_search_result(msg):
            """Clean and sort a result."""
            
            def cmp_path(dn1, dn2):
                """Compare path tuples."""
                p1 = self.treemodel.get_path(self.treenodes[dn1])
                p2 = self.treemodel.get_path(self.treenodes[dn2])
                for i1, i2 in zip(p1, p2):
                    if i1 != i2:
                        return cmp(i1, i2)
                return cmp(len(p1), len(p2))
                
            ret = [ str(x['dn']) for x in msg ]
            # filter special dn's if they are not in displayed DnTree
            ret = list(set(ret).intersection(self.tree.dn_set))
            
            if DEBUG:
                print "make_search_result: sort start", time.time()
                
            ret.sort(cmp_path)
            
            if DEBUG:
                print "make_search_result: sort finish", time.time()
                print "make_search_result: result:"
                for i in ret:
                    print i
                    
            return ret
        
        mode, query, flags = self.cur_search
        
        if DEBUG:
            print "set_search:", mode, query, flags
        
        self.sync_tree()
        
        if mode == "ldap":
            try:
                if DEBUG:
                    print "make_search_result: query start", time.time()
                    
                result = self.ldb.search(expression=query, attrs=['dn'])
                
                if DEBUG:
                    print "make_search_result: query finish", time.time()
                    
                self.search_result = make_search_result(result)
                
            except ldb.LdbError, err:
                self.search_result = None
                self.ldb_error_exception(err)
                return
                
        elif mode == "text":
            dialog = gtk.MessageDialog(self,
                gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_INFO,
                gtk.BUTTONS_CLOSE, "Not implemented yet!")
            # Close dialog on user response
            dialog.connect ("response", lambda d, r: d.destroy())
            dialog.set_modal(True)
            dialog.show()
            return
            
        if len(self.search_result) > 0:
            self.find_next()
        else:
            dialog = gtk.MessageDialog(self,
                    gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_INFO,
                    gtk.BUTTONS_CLOSE, "Not found!")
            # Close dialog on user response
            dialog.connect ("response", lambda d, r: d.destroy())
            dialog.set_modal(True)
            dialog.show()
            
    def _cb_find(self, button):
        """Show search dialog."""
        dialog = SearchDialog(self)
        if dialog.run() == gtk.RESPONSE_OK:
            self.cur_search = dialog.get_search()
            self.do_search()
        dialog.destroy()
        
    def find_next(self):
        """Set cursor to next found entry."""
        
        if self.search_result == None:
            if DEBUG:
                print "find_next: no search result"
            return
        
        if len(self.search_result) == 0:
            dialog = gtk.MessageDialog(None, gtk.DIALOG_DESTROY_WITH_PARENT,
                    gtk.MESSAGE_QUESTION, gtk.BUTTONS_YES_NO,
                    "No more entries found. Restart search?")
            dialog.show()
            if dialog.run() == gtk.RESPONSE_YES:
                if DEBUG:
                    print "find_next: restart!"
                self.do_search()
            dialog.destroy()
            return
        
        if DEBUG:
            print 'find_next: found "%s"' % self.search_result[0]
        
        path = ":".join(map(str, self.treemodel.get_path(
                                    self.treenodes[self.search_result[0]])))
        
        if DEBUG:
            print "find_next: path", path
        
        pos = path.rfind(":")
        
        if pos != -1:
            self.treeview.expand_to_path(path[:pos])
        self.treeview.set_cursor(path)
        
        self.search_result = self.search_result[1:]
        
    def _cb_connect(self, button):
        """Show dialog and connect to specified url."""
        dialog = LdbURLDialog(self)
        if dialog.run() == gtk.RESPONSE_OK:
            try:
                self.set_ldb(get_ldb(dialog.get_url()))
            except ldb.LdbError, err:
                self.ldb_error_exception(err)
        dialog.destroy()
        
    def _cb_disconnect(self, button):
        """Clear display and close ldb connection."""
        self.treemodel.clear()
        self.attributemodel.clear()
        self.menu_disconnect.set_sensitive(False)
        self.cur_selected_dn = None
        self.ldb = None
        
    def _cb_open(self, button):
        """Show dialog and open specified file."""
        dialog = gtk.FileChooserDialog(title="Please choose a file",
            parent=self,
            buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                gtk.STOCK_OPEN, gtk.RESPONSE_OK))
        if dialog.run() == gtk.RESPONSE_OK:
            self.set_ldb(get_ldb(dialog.get_filename()))
            
        dialog.destroy()
        
    def add_node(self, dn, parent_dn=None, parent_node=None, text=None):
        """Add node to treemodel.
        
        dn          --- distinguished name of node (str)
        parent_dn   --- distinguished name of parent node (str)
        parent_node --- parent node (gtk.TreeIter)
        text        --- caption of node (str)
        """
        if parent_dn == None: parent_dn = self.tree.get_parent_dn(dn)
        if parent_node == None: parent_node = self.treenodes[parent_dn]
        if text == None:
            if parent_dn == "":
                text = dn
            else:
                text = get_rdn(dn)
                
        if DEBUG:
            print "add_node: adding node", dn
            print "add_node: parent:", parent_dn
            print "add_node: parent iter:", parent_node
            print "add_node: text:", text
            
        if dn in self.treenodes.keys():
            if DEBUG:
                print "add_node: old entry found"
            self.remove_node(dn)
            if DEBUG:
                print "add_node: old entry removed."
                
        cur_node = self.treemodel.append(parent_node, [text, dn, True])
        self.treenodes[dn] = cur_node
        
        if DEBUG:
            print "add_node: node iter:", cur_node
            print
            
        if dn in self.tree.childs.keys():
            for child in self.tree.childs[dn]:
                self.add_node(child, dn, cur_node)
                
    def remove_node(self, dn):
        """Remove node from treemodel.
        
        dn --- distinguished name of node to remove (str)
        """
        
        if dn in self.tree.childs.keys():
            childs = tuple(self.tree.childs[dn])
            for i in childs:
                self.remove_node(i)
                
        if DEBUG:
            print 'remove_node %s' % dn
            try:
                print 'childs:\n    %s' % "\n    ".join(childs)
            except NameError:
                pass
            
        self.treemodel.remove(self.treenodes[dn])
        self.treenodes.pop(dn)
        
    def set_ldb(self, ldb):
        """Change the LDB object displayed.
        
        Will refresh the window.
        ldb -- New LDB object to use.
        """
        self.ldb = ldb
        self.menu_disconnect.set_sensitive(True)
        self.build_tree()
        
    def get_all_dn_set(self):
        """Return set of dn strings of elements in database."""
        if self.hide_special:
            try:
                return set(map(lambda x: str(x.dn),
                                  filter(lambda x: not x.dn.is_special(),
                                        self.ldb.search(attrs=['dn']))))
            except ldb.LdbError, err:
                self.ldb_error_exception(err)
                return set()
        else:
            try:
                return set(map(lambda x: str(x.dn),
                                        self.ldb.search(attrs=['dn'])))
            except ldb.LdbError, err:
                self.ldb_error_exception(err)
                return set()
                
    def build_tree(self):
        """Build LDB tree and display it in treeview."""
        
        self.tree = DnTree(self.get_all_dn_set())
        
        if DEBUG:
            print "build_tree:"
            print self.tree
        
        self.treemodel.clear()
        self.treenodes = {}
        self.treenodes[""] = None
        
        root_dn = self.tree.get_roots()
        root_dn.sort()
        
        if DEBUG:
            print "build_tree: root_dn: %s" % "; ".join(root_dn)
            
        for dn in root_dn:
            self.add_node(dn, "", text=dn)
            
    def sync_tree(self):
        """Syncronize tree and treeview with database after minor change."""
        
        if DEBUG:
            print 'sync_tree: begin'
            print self.tree
        
        new_dn_set = self.get_all_dn_set()
        
        dn_to_remove = self.tree.dn_set.difference(new_dn_set)
        
        if DEBUG:
            print 'sync_tree: dn_to_remove\n%s\n' % DnTree(dn_to_remove)
            
        for dn in DnTree(dn_to_remove).get_roots():
            if DEBUG: print 'sync_tree: removing %s' % dn
            self.remove_node(dn)
            self.tree.remove(dn)
            
        dn_to_add = new_dn_set.difference(self.tree.dn_set)
        
        if DEBUG:
            print 'sync_tree: dn_to_add\n%s\n' % DnTree(dn_to_add)
            
        for dn in dn_to_add:
            if DEBUG: print 'sync_tree: adding %s to tree' % dn
            self.tree.add(dn)
            
        for dn in DnTree(dn_to_add).get_roots():
            if DEBUG: print 'sync_tree: adding to treemodel %s' % dn
            self.add_node(dn)
            
        if DEBUG:
            print 'sync_tree: end'
            print self.tree
            
    def _toggle_special_entries(self, item):
        """Toggle "hide special" option and refresh a tree."""
        self.hide_special = not self.hide_special
        if self.ldb != None:
            self.sync_tree()
            
    def refresh_attributes(self):
        """Clear and fill an attribute widget."""
        
        self.attributemodel.clear()
        
        if self.cur_selected_dn == None:
            self.dn_label.set_text("")
            return
        
        try:
            msg = self.ldb.search(self.cur_selected_dn, ldb.SCOPE_BASE)[0]
        except ldb.LdbError, err:
            self.ldb_error_exception(err)
            return
        
        self.dn_label.set_text(str(msg.dn))
        
        for name, el in msg.items():
            if name == "dn":
                continue
            el = [ self.ldb.schema_format_value(name, val) for val in el ]
            if name == "distinguishedName":
                continue
            el = tuple(el)
            if DEBUG:
                print "refresh_attributes:", name, el
            for val in el:
                if DEBUG:
                    print 'refresh_attributes: adding value "%s"' % val
                self.attributemodel.append([name, val, True])
                
    def _dn_cursor_changed(self, item):
        """Change currently selected dn and refresh attributes."""
        (model, iter) = item.get_selection().get_selected()
        if iter == None:
            self.cur_selected_dn = None
        else:
            self.cur_selected_dn = model.get_value(iter, 1)
        self.refresh_attributes()
        
    def _dn_button_press(self, treeview, event):
        """Show right-click popup menu to add or delete element."""
        
        def add_dn(parent):
            if parent == "":
                dn = ""
            else:
                dn = "CN=," + parent
            dn_dialog = gtk.Dialog(parent=self,
                buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                         gtk.STOCK_ADD, gtk.RESPONSE_OK))
            dn_entry = gtk.Entry()
            dn_entry.set_text(dn)
            dn_dialog.vbox.add(dn_entry)
            dn_dialog.set_title("Enter DN:")
            dn_dialog.show_all()
            if dn_dialog.run() == gtk.RESPONSE_OK:
                dn = dn_entry.get_text()
                try:
                    msg = ldb.Message(ldb.Dn(self.ldb, dn))
                    self.ldb.add(msg)
                except (ldb.LdbError, ValueError), err:
                    dialog = gtk.MessageDialog(self,
                        gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR,
                        gtk.BUTTONS_CLOSE, str(err))
                    # Close dialog on user response
                    dialog.connect ("response", lambda d, r: d.destroy())
                    dialog.show()
                self.sync_tree()
            dn_dialog.destroy()
            
        def delete_dn(dn):
            try:
                self.ldb.delete(ldb.Dn(self.ldb, dn))
            except (ldb.LdbError, ValueError), err:
                dialog = gtk.MessageDialog(self,
                    gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR,
                    gtk.BUTTONS_CLOSE, str(err))
                # Close dialog on user response
                dialog.connect ("response", lambda d, r: d.destroy())
                dialog.show()
            self.sync_tree()
            self.cur_selected_dn = None
            self.refresh_attributes()
            
        if self.ldb == None:
            return
        
        if event.button == 3:
            x = int(event.x)
            y = int(event.y)
            time = event.time
            pthinfo = treeview.get_path_at_pos(x, y)
            if pthinfo is not None:
                path, col, cellx, celly = pthinfo
                path_str = ":".join(map(str, path))
                iter = self.treemodel.get_iter_from_string(path_str)
                
                treeview.grab_focus()
                treeview.set_cursor(path, col, 0)
                
                dn = self.treemodel[iter][1]
                
                popup = gtk.Menu()
                el = gtk.ImageMenuItem(gtk.STOCK_ADD)
                el.connect('activate', lambda x: add_dn(dn))
                popup.add(el)
                el = gtk.ImageMenuItem(gtk.STOCK_DELETE)
                el.connect('activate', lambda x: delete_dn(dn))
                popup.add(el)
                popup.show_all()
                popup.popup(None, None, None, event.button, time)
            else:
                popup = gtk.Menu()
                el = gtk.ImageMenuItem(gtk.STOCK_ADD)
                el.connect('activate', lambda x: add_dn(""))
                popup.add(el)
                popup.show_all()
                popup.popup(None, None, None, event.button, time)
                
    def _dn_cell_edited(self, cell, path_string, new_rdn):
        """Rename an element."""
        
        iter = self.treemodel.get_iter_from_string(path_string)
        
        old_dn = self.treemodel[iter][1]
        old_rdn = get_rdn(old_dn)
        
        if old_rdn == new_rdn:
            return
        
        parent_dn = self.tree.parent[old_dn]
        
        if parent_dn != "":
            new_dn = new_rdn + "," + parent_dn
        else:
            new_dn = new_rdn
        
        if DEBUG:
            print old_dn, "-->", new_dn
        
        try:
            self.ldb.rename(ldb.Dn(self.ldb, old_dn), new_dn)
        except ldb.LdbError, err:
            self.ldb_error_exception(err)
            return
        
        self.sync_tree()
        
    def _msg_cell_edited(self, cell, path_string, text):
        """Edit the element."""
        
        column = cell.get_data("column")
        
        iter = self.attributemodel.get_iter_from_string(path_string)
        
        old_attr = self.attributemodel[iter][0]
        old_value = self.attributemodel[iter][1]
        
        if DEBUG:
            print "_msg_cell_edited: %s=%s" % (old_attr, old_value)
            
        if column == 0: # edited name
            
            if text == old_attr:
                return
            
            m = ldb.Message()
            m.dn = ldb.Dn(self.ldb, self.cur_selected_dn)
            m[old_attr] = ldb.MessageElement(old_value,
                ldb.CHANGETYPE_MODIFY, old_attr)
            
            if DEBUG:
                print '_msg_cell_edited: delete attr "%s=%s"' % \
                    (old_attr, old_value)
                print m
            
            try:
                self.ldb.modify(m)
            except ldb.LdbError, err:
                self.ldb_error_exception(err)
                return
            
            m = ldb.Message()
            m.dn = ldb.Dn(self.ldb, self.cur_selected_dn)
            m[text] = ldb.MessageElement(old_value,
                ldb.CHANGETYPE_ADD, text)
            
            if DEBUG:
                print '_msg_cell_edited: add "%s=%s"' % \
                    (text, old_value)
                print m
                
            try:
                self.ldb.modify(m)
            except ldb.LdbError, err:
                self.ldb_error_exception(err)
                return
            
            if DEBUG:
                print "_msg_cell_edited: modified!"
                print self.ldb.search(self.cur_selected_dn, ldb.SCOPE_BASE)[0]
            
            self.refresh_attributes()
            
        elif column == 1: # edited value
            
            if text == old_value:
                return
            
            m = ldb.Message()
            m.dn = ldb.Dn(self.ldb, self.cur_selected_dn)
            m[old_attr] = ldb.MessageElement(old_value,
                ldb.CHANGETYPE_MODIFY, old_attr)
            
            if DEBUG:
                print '_msg_cell_edited: delete ', old_value
                print m
                
            try:
                self.ldb.modify(m)
            except ldb.LdbError, err:
                self.ldb_error_exception(err)
                return
            
            m = ldb.Message()
            m.dn = ldb.Dn(self.ldb, self.cur_selected_dn)
            m[old_attr] = ldb.MessageElement(text,
                ldb.CHANGETYPE_ADD, old_attr)
            
            if DEBUG:
                print '_msg_cell_edited: add "%s"' % text
                print m
                
            try:
                self.ldb.modify(m)
            except ldb.LdbError, err:
                self.ldb_error_exception(err)
                return
            
            if DEBUG:
                print "_msg_cell_edited: modified!"
                print self.ldb.search(self.cur_selected_dn, ldb.SCOPE_BASE)[0]
                
            self.refresh_attributes()
            
    def _msg_button_press(self, treeview, event):
        """Show right-click popup menu to add or delete element."""
        
        def add_attr():
            
            dialog = gtk.Dialog(parent=self,
                buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                         gtk.STOCK_ADD, gtk.RESPONSE_OK))
            attr_entry = gtk.Entry()
            attr_entry.set_text("Name")
            value_entry = gtk.Entry()
            value_entry.set_text("Value")
            dialog.vbox.add(attr_entry)
            dialog.vbox.add(value_entry)
            dialog.show_all()
            if dialog.run() == gtk.RESPONSE_OK:
                
                attr = attr_entry.get_text()
                value = value_entry.get_text()
                
                m = ldb.Message()
                m.dn = ldb.Dn(self.ldb, self.cur_selected_dn)
                m[attr] = ldb.MessageElement(value,
                        ldb.CHANGETYPE_ADD, attr)
                
                if DEBUG:
                    print 'message:', m
                    print 'before add:'
                    print self.ldb.search(self.cur_selected_dn, ldb.SCOPE_BASE)[0]
                    
                try:
                    self.ldb.modify(m)
                except ldb.LdbError, err:
                    self.ldb_error_exception(err)
                    return
                
                if DEBUG:
                    print 'after add:'
                    print self.ldb.search(self.cur_selected_dn, ldb.SCOPE_BASE)[0]
                    
                self.refresh_attributes()
                
            dialog.destroy()
            
        def delete_attr(dn, attr, value):
            
            m = ldb.Message()
            m.dn = ldb.Dn(self.ldb, dn)
            m[attr] = ldb.MessageElement(value, ldb.CHANGETYPE_MODIFY, attr)
            
            if DEBUG:
                print 'delete_item: delete "%s=%s" from %s' % (attr, value, dn)
                print 'before:', self.ldb.search(dn, ldb.SCOPE_BASE)[0]
                
            try:
                self.ldb.modify(m)
            except ldb.LdbError, err:
                self.ldb_error_exception(err)
                return
            
            if DEBUG:
                print 'after:', self.ldb.search(dn, ldb.SCOPE_BASE)[0]
                
            self.refresh_attributes()
            
        if self.cur_selected_dn is None:
            return
        
        if event.button == 3:
            x = int(event.x)
            y = int(event.y)
            time = event.time
            pthinfo = treeview.get_path_at_pos(x, y)
            if pthinfo is not None:
                path, col, cellx, celly = pthinfo
                path_str = ":".join(map(str, path))
                iter = self.attributemodel.get_iter_from_string(path_str)
                
                treeview.grab_focus()
                treeview.set_cursor(path, col, 0)
                
                dn = self.cur_selected_dn
                attr = self.attributemodel[iter][0]
                value = self.attributemodel[iter][1]
                
                popup = gtk.Menu()
                el = gtk.MenuItem("_Delete")
                el.connect('activate', lambda x: delete_attr(dn, attr, value))
                popup.add(el)
                popup.show_all()
                popup.popup(None, None, None, event.button, time)
            else:
                popup = gtk.Menu()
                el = gtk.MenuItem("_Add")
                el.connect('activate', lambda x: add_attr())
                popup.add(el)
                popup.show_all()
                popup.popup(None, None, None, event.button, time)
                
    def _cb_about(self, button):
        """Show about dialog."""
        dialog = gtk.AboutDialog()
        dialog.set_name(self.get_title())
        dialog.set_comments(__doc__)
        dialog.set_authors(__authors__)
        dialog.set_license(open(os.path.dirname(os.path.abspath(__file__)) + \
                                '/LICENSE').read())
        dialog.set_website("http://www.samba.org/")
        ## Close dialog on user response
        dialog.connect ("response", lambda d, r: d.destroy())
        dialog.show()


class SearchDialog(gtk.Dialog):
    """Dialog to get what to search."""
    def __init__(self, parent=None):
        """Create a new SearchDialog."""
        
        self.ldap_flags = None
        self.text_flags = None
        
        super(SearchDialog, self).__init__(parent=parent,
                buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                         gtk.STOCK_FIND, gtk.RESPONSE_OK))
        try:
            self.set_screen(parent.get_screen())
        except AttributeError:
            self.connect('destroy', lambda *w: gtk.main_quit())
            
        self.set_title("Find")
        self.set_resizable(False)
        
        vbox = gtk.VBox()
        self.vbox.pack_start(vbox, True, True, 0)
        
        self.expander1 = gtk.Expander("LDAP Query")
#        vbox.pack_start(self.expander1, False, True, 0)
        
        hbox = gtk.HBox()
        hbox.set_border_width(5)
        label = gtk.Label("Query:")
        hbox.pack_start(label, False)
        self.ldap_query = gtk.Entry()
        hbox.add(self.ldap_query)
#        self.expander1.add(hbox)
        self.expander1.set_expanded(True)
        self.expander1.connect('activate', self._activate1)
        
        self.vbox.add(hbox)
        
        self.expander2 = gtk.Expander("Simple search")
#        vbox.pack_start(self.expander2, False, True, 0)
        
        vbox2 = gtk.VBox()
        vbox2.set_border_width(5)
        
        hbox = gtk.HBox()
        hbox.set_border_width(5)
        label = gtk.Label("Find:")
        hbox.pack_start(label, False)
        self.text_query = gtk.Entry()
        hbox.add(self.text_query)
        vbox2.add(hbox)
        
        self.text_keys = gtk.CheckButton("Keys")
        vbox2.add(self.text_keys)
        self.text_names = gtk.CheckButton("Value names")
        vbox2.add(self.text_names)
        self.text_contents = gtk.CheckButton("Value contents")
        vbox2.add(self.text_contents)
        self.text_whole_string_only = gtk.CheckButton("Whole string only")
        vbox2.add(self.text_whole_string_only)
        
        self.expander2.add(vbox2)
        self.expander2.set_expanded(False)
        self.expander2.connect('activate', self._activate2)
        
        self.show_all()
        
    def _activate1(self, expander):
        """Toggle second expander when first activated."""
        self.expander2.set_expanded(not self.expander2.get_expanded())
        
    def _activate2(self, expander):
        """Toggle first expander when second activated."""
        self.expander1.set_expanded(not self.expander1.get_expanded())
        
    def get_search(self):
        """Return tuple of mode, query and flags to search."""
        if self.expander1.get_expanded():
            return ("ldap", self.ldap_query.get_text(), self.ldap_flags)
        return ("text", self.text_query.get_text(), self.text_flags)


def main():
    browser = LdbBrowser()
    if len(sys.argv) > 1:
        browser.set_ldb(get_ldb(sys.argv[1]))
    gtk.main()

if __name__ == "__main__":
    main()
